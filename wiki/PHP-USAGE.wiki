=使用需求=
本说明主要针对命令行模式
==1.在命令行模式运行==
应用程序的运行使用PHP命令行模式，所以在编译PHP的时候需要激活CLI模式，
以Demo为例，首先进入Demo根目录，执行以下命令来运行程序

  php run.php

上面的命令将会让程序占用当前终端，所以需要按下面的方式让其以守护进程方式运行：
  
  php run.php -d
  
或者在应用程序配置文件中增加配置项目

  $_CFG->web->daemon = true;
  
==2.PHP运行版本不能小于5.3==
框架中大量使用了PHP Spl类库，PHP版本不能小于 5.3.0
==3.运行需要扩展==
  # libevent
  # pcntl
  # posix
  # proctitle
  # shmop
如果你不确定是否安装，可以尝试运行程序，程序会检查是否存在相关扩展，并且会以异常形式返回相关信息
=配置=
==1.配置文件==
框架默认配置文件为config.default.php, 应用自己的配置文件位于应用的数据存储目录下面的conf目录下面的config.php文件。
例如Demo的配置文件位于

  demo/var/conf/config.php
  
用户配置文件修改的值会覆盖掉默认配置文件中的值。
例如,设置WEB服务器Document目录，可以直接使用下面的代码，不要声明$_CFG->web这个对象
  
  $_CFG->web->document_root = ‘/’；
  
所有配置项见默认配置文件说明
==2.框架需要定义的常量==
应用程序可以定义以下常量:
  # __X_IN_FRAME__     该值只能为true,
  # __X_APP_ROOT__     设置用户应用程序所在目录,默认为当前执行目录
  # __X_SHOW_ERROR__   是否显示错误异常和trace信息
     ## true 将在页面中输出，但是不将错误信息记录到日志中
     ## false 将不在页面中显示，但是会将错日志写入日志文件中
     ## null  将屏蔽所有错误信息的显示，并且不记录到日志文件中
  # __X_EXCEPTION_LEVEL__ 设置异常等级, 
     ## 0 为所有信息，
     ## 1 将不抛出notice信息，
     ## 2 将不抛出Warning和notice信息
  * __X_APP_DATA_DIR_NAME__ 数据目录名__X_APP_ROOT__目录下面
以Demo为例，建议将这些常量定义在run.php中
==3.调用框架==
以Demo为例,只要run.php中包含框架的__init__.php文件，然后在命令行模式运行run.php即可
  
  include_once(dirname(dirname(__FILE__)) . '/current/__init__.php');
  
=主要部件=
==1.调度器==
调度器的实现是使用 *XScheduler* 类实现
   
  final class XScheduler extends XObject {}   //对于应用不可见
  
==2.WEB服务器==
WEB服务器使用多进程模式，由 *XWebServer* 类实现，对应用不可见
  
  final class XWebServer {
  public function __construct( XScheduler $scheduler) {} //需要传入一个调度器实例（Object XScheduler）
  public function exit_alert(XException $e) {} //程序异常退出时会执行，需要传入一个异常实例（Object XException）
  
WEB服务器配置项为
  
  $_CFG->web 对象
  
==3.数据请求接口==
本接口目前没有实现，但是目前可以调用一个MySQL的对象化的类，以及一个K/V文本数据库
==4.异常处理==
本框架的异常处理类，由 *XException* 类实现，异常类会转化PHP错误信息，并且抛出回溯信息
  
   class XException  extends ErrorException {}
  
抛出的异常类似以下格式
   
  XException Error : can not load pcntl extension , you can use "php -d enable_dl" in command line that enable dl load function
  Throw Exception in file /home/chopin/bin/dcolors/current/XFunction.php line 509
  #0 dl_extension( 'pcntl','pcntl_fork') in /home/chopin/bin/dcolors/current/XWebServer.php line 293;
  #1 XWebServer->check_extension( ) in /home/chopin/bin/dcolors/current/XWebServer.php line 88;
  #2 XWebServer->__construct( Object XScheduler) in /home/chopin/bin/dcolors/current/XScheduler.php line 45;
  #3 XScheduler->__construct( ) in /home/chopin/bin/dcolors/current/__init__.php line 53;
  #4 include_once( '/home/chopin/bin/dcolors/current') in /home/chopin/bin/dcolors/demo/run.php line 16;
---
  # 第一行是错误信息
  # 第二行式抛出错误的地方
  # 第三开始式回溯信息，错误发生点往前追溯，也就是与程序执行顺序刚好相反
==5.业务逻辑限制==
这个限制主要体现在应用必须继承 *X* 类
  
  abstract class X {
      public-readonly XRequest $R; //外部数据对象
      public-readonly XTemplate $T; //模板类实例
      public function __xget__($name) {} //必须通过覆盖次方法实现PHP魔术方法__get()
      public function __xset__($name,$value) {}//必须通过覆盖次方法实现PHP魔术方法__set()
  }
    
==6.模板处理==
模板类为 *XTemplate* 类，对应用不能直接可见
  
  final class XTemplate {}
  
在应用中使用从 *X* 类集成的只读属性 *$T* 来访问，主要通过设置其相关属性来实现页面输出控制，例如
  string $this->T->name = ''; //设置页面 _模板/UI/皮肤_ 文件, 如果没有设置此值，将会有 `$this->T=null`
  stdClass $this->D ; //需要设置的模板中使用的变量对象
  $this->D->title_name = 'framework'; //设置一个模板变量$title_name, 在模板文件中使用 {$title_name} 来访问

